// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: token/v1/transaction.proto

package tokenv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransactionMultiError, or
// nil if none found.
func (m *Transaction) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Contract

	// no validation rules for Network

	switch v := m.Data.(type) {
	case *Transaction_DeployNewSecurityToken:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeployNewSecurityToken()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "DeployNewSecurityToken",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "DeployNewSecurityToken",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeployNewSecurityToken()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "DeployNewSecurityToken",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_BulkIssueByPartition:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBulkIssueByPartition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "BulkIssueByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "BulkIssueByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBulkIssueByPartition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "BulkIssueByPartition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_SetDocument:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetDocument()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "SetDocument",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "SetDocument",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetDocument()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "SetDocument",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_IssueByPartition:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetIssueByPartition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "IssueByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "IssueByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetIssueByPartition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "IssueByPartition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_RedeemByPartition:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRedeemByPartition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "RedeemByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "RedeemByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRedeemByPartition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "RedeemByPartition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_OperatorRedeemByPartition:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOperatorRedeemByPartition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "OperatorRedeemByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "OperatorRedeemByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOperatorRedeemByPartition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "OperatorRedeemByPartition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_RenounceControl:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRenounceControl()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "RenounceControl",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "RenounceControl",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRenounceControl()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "RenounceControl",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_RenounceIssuance:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRenounceIssuance()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "RenounceIssuance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "RenounceIssuance",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRenounceIssuance()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "RenounceIssuance",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_Pause:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPause()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Pause",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Pause",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPause()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "Pause",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_Unpause:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetUnpause()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Unpause",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Unpause",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUnpause()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "Unpause",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_TransferOwnership:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTransferOwnership()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "TransferOwnership",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "TransferOwnership",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTransferOwnership()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "TransferOwnership",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_AuthorizeOperator:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuthorizeOperator()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "AuthorizeOperator",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "AuthorizeOperator",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthorizeOperator()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "AuthorizeOperator",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_RevokeOperator:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRevokeOperator()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "RevokeOperator",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "RevokeOperator",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRevokeOperator()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "RevokeOperator",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_TransferByPartition:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTransferByPartition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "TransferByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "TransferByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTransferByPartition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "TransferByPartition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_OperatorTransferByPartition:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetOperatorTransferByPartition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "OperatorTransferByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "OperatorTransferByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOperatorTransferByPartition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "OperatorTransferByPartition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_AuthorizeOperatorByPartition:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAuthorizeOperatorByPartition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "AuthorizeOperatorByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "AuthorizeOperatorByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAuthorizeOperatorByPartition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "AuthorizeOperatorByPartition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_RevokeOperatorByPartition:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRevokeOperatorByPartition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "RevokeOperatorByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "RevokeOperatorByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRevokeOperatorByPartition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "RevokeOperatorByPartition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_TransferWithData:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTransferWithData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "TransferWithData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "TransferWithData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTransferWithData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "TransferWithData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_TransferFromWithData:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTransferFromWithData()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "TransferFromWithData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "TransferFromWithData",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTransferFromWithData()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "TransferFromWithData",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_Transfer:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTransfer()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Transfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Transfer",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTransfer()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "Transfer",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_Approve:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetApprove()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Approve",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Approve",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetApprove()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "Approve",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_TransferFrom:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetTransferFrom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "TransferFrom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "TransferFrom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetTransferFrom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "TransferFrom",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_SetCap:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetCap()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "SetCap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "SetCap",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetCap()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "SetCap",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_SetModulesByPartition:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetModulesByPartition()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "SetModulesByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "SetModulesByPartition",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetModulesByPartition()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "SetModulesByPartition",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_AddRole:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAddRole()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "AddRole",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "AddRole",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAddRole()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "AddRole",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_BulkAddRole:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBulkAddRole()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "BulkAddRole",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "BulkAddRole",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBulkAddRole()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "BulkAddRole",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_RemoveRole:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRemoveRole()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "RemoveRole",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "RemoveRole",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRemoveRole()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "RemoveRole",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_RenounceRole:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRenounceRole()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "RenounceRole",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "RenounceRole",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRenounceRole()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "RenounceRole",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_DeploySpendingLimitsConstraintModule:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeploySpendingLimitsConstraintModule()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "DeploySpendingLimitsConstraintModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "DeploySpendingLimitsConstraintModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeploySpendingLimitsConstraintModule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "DeploySpendingLimitsConstraintModule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_AddTimelock:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAddTimelock()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "AddTimelock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "AddTimelock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAddTimelock()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "AddTimelock",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_SetTimelock:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetTimelock()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "SetTimelock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "SetTimelock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetTimelock()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "SetTimelock",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_DeleteTimelock:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeleteTimelock()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "DeleteTimelock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "DeleteTimelock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeleteTimelock()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "DeleteTimelock",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_DeployTimeLockConstraintModule:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeployTimeLockConstraintModule()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "DeployTimeLockConstraintModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "DeployTimeLockConstraintModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeployTimeLockConstraintModule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "DeployTimeLockConstraintModule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_EditAmountTimeLock:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEditAmountTimeLock()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "EditAmountTimeLock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "EditAmountTimeLock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEditAmountTimeLock()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "EditAmountTimeLock",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_EditAccountTimeLock:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEditAccountTimeLock()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "EditAccountTimeLock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "EditAccountTimeLock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEditAccountTimeLock()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "EditAccountTimeLock",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_EditTimeLock:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEditTimeLock()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "EditTimeLock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "EditTimeLock",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEditTimeLock()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "EditTimeLock",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_DeployVestingPeriodConstraintModule:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeployVestingPeriodConstraintModule()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "DeployVestingPeriodConstraintModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "DeployVestingPeriodConstraintModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeployVestingPeriodConstraintModule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "DeployVestingPeriodConstraintModule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_SetVestingOptions:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetVestingOptions()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "SetVestingOptions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "SetVestingOptions",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetVestingOptions()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "SetVestingOptions",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_DeployWhitelistConstraintModule:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDeployWhitelistConstraintModule()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "DeployWhitelistConstraintModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "DeployWhitelistConstraintModule",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDeployWhitelistConstraintModule()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "DeployWhitelistConstraintModule",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_EditWhitelist:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEditWhitelist()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "EditWhitelist",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "EditWhitelist",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEditWhitelist()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "EditWhitelist",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Transaction_BulkEditWhitelist:
		if v == nil {
			err := TransactionValidationError{
				field:  "Data",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetBulkEditWhitelist()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "BulkEditWhitelist",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "BulkEditWhitelist",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBulkEditWhitelist()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "BulkEditWhitelist",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if m.Metadata != nil {

		if all {
			switch v := interface{}(m.GetMetadata()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Metadata",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  "Metadata",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetMetadata()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  "Metadata",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TransactionMultiError(errors)
	}

	return nil
}

// TransactionMultiError is an error wrapping multiple validation errors
// returned by Transaction.ValidateAll() if the designated constraints aren't met.
type TransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionMultiError) AllErrors() []error { return m }

// TransactionValidationError is the validation error returned by
// Transaction.Validate if the designated constraints aren't met.
type TransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionValidationError) ErrorName() string { return "TransactionValidationError" }

// Error satisfies the builtin error interface
func (e TransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionValidationError{}

// Validate checks the field values on Transaction_SecurityTokenFactory with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *Transaction_SecurityTokenFactory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_SecurityTokenFactory with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Transaction_SecurityTokenFactoryMultiError, or nil if none found.
func (m *Transaction_SecurityTokenFactory) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SecurityTokenFactory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_SecurityTokenFactoryMultiError(errors)
	}

	return nil
}

// Transaction_SecurityTokenFactoryMultiError is an error wrapping multiple
// validation errors returned by
// Transaction_SecurityTokenFactory.ValidateAll() if the designated
// constraints aren't met.
type Transaction_SecurityTokenFactoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SecurityTokenFactoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SecurityTokenFactoryMultiError) AllErrors() []error { return m }

// Transaction_SecurityTokenFactoryValidationError is the validation error
// returned by Transaction_SecurityTokenFactory.Validate if the designated
// constraints aren't met.
type Transaction_SecurityTokenFactoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SecurityTokenFactoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_SecurityTokenFactoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_SecurityTokenFactoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_SecurityTokenFactoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_SecurityTokenFactoryValidationError) ErrorName() string {
	return "Transaction_SecurityTokenFactoryValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SecurityTokenFactoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SecurityTokenFactory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SecurityTokenFactoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SecurityTokenFactoryValidationError{}

// Validate checks the field values on Transaction_SecurityToken with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_SecurityToken) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_SecurityToken with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_SecurityTokenMultiError, or nil if none found.
func (m *Transaction_SecurityToken) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SecurityToken) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_SecurityTokenMultiError(errors)
	}

	return nil
}

// Transaction_SecurityTokenMultiError is an error wrapping multiple validation
// errors returned by Transaction_SecurityToken.ValidateAll() if the
// designated constraints aren't met.
type Transaction_SecurityTokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SecurityTokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SecurityTokenMultiError) AllErrors() []error { return m }

// Transaction_SecurityTokenValidationError is the validation error returned by
// Transaction_SecurityToken.Validate if the designated constraints aren't met.
type Transaction_SecurityTokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SecurityTokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_SecurityTokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_SecurityTokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_SecurityTokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_SecurityTokenValidationError) ErrorName() string {
	return "Transaction_SecurityTokenValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SecurityTokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SecurityToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SecurityTokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SecurityTokenValidationError{}

// Validate checks the field values on Transaction_Pausable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_Pausable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_Pausable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_PausableMultiError, or nil if none found.
func (m *Transaction_Pausable) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_Pausable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_PausableMultiError(errors)
	}

	return nil
}

// Transaction_PausableMultiError is an error wrapping multiple validation
// errors returned by Transaction_Pausable.ValidateAll() if the designated
// constraints aren't met.
type Transaction_PausableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_PausableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_PausableMultiError) AllErrors() []error { return m }

// Transaction_PausableValidationError is the validation error returned by
// Transaction_Pausable.Validate if the designated constraints aren't met.
type Transaction_PausableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_PausableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_PausableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_PausableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_PausableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_PausableValidationError) ErrorName() string {
	return "Transaction_PausableValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_PausableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_Pausable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_PausableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_PausableValidationError{}

// Validate checks the field values on Transaction_Ownable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_Ownable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_Ownable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_OwnableMultiError, or nil if none found.
func (m *Transaction_Ownable) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_Ownable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_OwnableMultiError(errors)
	}

	return nil
}

// Transaction_OwnableMultiError is an error wrapping multiple validation
// errors returned by Transaction_Ownable.ValidateAll() if the designated
// constraints aren't met.
type Transaction_OwnableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_OwnableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_OwnableMultiError) AllErrors() []error { return m }

// Transaction_OwnableValidationError is the validation error returned by
// Transaction_Ownable.Validate if the designated constraints aren't met.
type Transaction_OwnableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_OwnableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_OwnableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_OwnableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_OwnableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_OwnableValidationError) ErrorName() string {
	return "Transaction_OwnableValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_OwnableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_Ownable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_OwnableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_OwnableValidationError{}

// Validate checks the field values on Transaction_ERC1400Raw with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_ERC1400Raw) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_ERC1400Raw with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_ERC1400RawMultiError, or nil if none found.
func (m *Transaction_ERC1400Raw) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400Raw) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_ERC1400RawMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400RawMultiError is an error wrapping multiple validation
// errors returned by Transaction_ERC1400Raw.ValidateAll() if the designated
// constraints aren't met.
type Transaction_ERC1400RawMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400RawMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400RawMultiError) AllErrors() []error { return m }

// Transaction_ERC1400RawValidationError is the validation error returned by
// Transaction_ERC1400Raw.Validate if the designated constraints aren't met.
type Transaction_ERC1400RawValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400RawValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_ERC1400RawValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_ERC1400RawValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_ERC1400RawValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_ERC1400RawValidationError) ErrorName() string {
	return "Transaction_ERC1400RawValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400RawValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400Raw.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400RawValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400RawValidationError{}

// Validate checks the field values on Transaction_ERC1400Partition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_ERC1400Partition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_ERC1400Partition with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_ERC1400PartitionMultiError, or nil if none found.
func (m *Transaction_ERC1400Partition) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400Partition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_ERC1400PartitionMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400PartitionMultiError is an error wrapping multiple
// validation errors returned by Transaction_ERC1400Partition.ValidateAll() if
// the designated constraints aren't met.
type Transaction_ERC1400PartitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400PartitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400PartitionMultiError) AllErrors() []error { return m }

// Transaction_ERC1400PartitionValidationError is the validation error returned
// by Transaction_ERC1400Partition.Validate if the designated constraints
// aren't met.
type Transaction_ERC1400PartitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400PartitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_ERC1400PartitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_ERC1400PartitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_ERC1400PartitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_ERC1400PartitionValidationError) ErrorName() string {
	return "Transaction_ERC1400PartitionValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400PartitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400Partition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400PartitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400PartitionValidationError{}

// Validate checks the field values on Transaction_ERC1400ERC20 with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_ERC1400ERC20) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_ERC1400ERC20 with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_ERC1400ERC20MultiError, or nil if none found.
func (m *Transaction_ERC1400ERC20) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400ERC20) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_ERC1400ERC20MultiError(errors)
	}

	return nil
}

// Transaction_ERC1400ERC20MultiError is an error wrapping multiple validation
// errors returned by Transaction_ERC1400ERC20.ValidateAll() if the designated
// constraints aren't met.
type Transaction_ERC1400ERC20MultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400ERC20MultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400ERC20MultiError) AllErrors() []error { return m }

// Transaction_ERC1400ERC20ValidationError is the validation error returned by
// Transaction_ERC1400ERC20.Validate if the designated constraints aren't met.
type Transaction_ERC1400ERC20ValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400ERC20ValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_ERC1400ERC20ValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_ERC1400ERC20ValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_ERC1400ERC20ValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_ERC1400ERC20ValidationError) ErrorName() string {
	return "Transaction_ERC1400ERC20ValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400ERC20ValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400ERC20.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400ERC20ValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400ERC20ValidationError{}

// Validate checks the field values on Transaction_ERC1400Capped with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_ERC1400Capped) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_ERC1400Capped with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_ERC1400CappedMultiError, or nil if none found.
func (m *Transaction_ERC1400Capped) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400Capped) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_ERC1400CappedMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400CappedMultiError is an error wrapping multiple validation
// errors returned by Transaction_ERC1400Capped.ValidateAll() if the
// designated constraints aren't met.
type Transaction_ERC1400CappedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400CappedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400CappedMultiError) AllErrors() []error { return m }

// Transaction_ERC1400CappedValidationError is the validation error returned by
// Transaction_ERC1400Capped.Validate if the designated constraints aren't met.
type Transaction_ERC1400CappedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400CappedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_ERC1400CappedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_ERC1400CappedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_ERC1400CappedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_ERC1400CappedValidationError) ErrorName() string {
	return "Transaction_ERC1400CappedValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400CappedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400Capped.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400CappedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400CappedValidationError{}

// Validate checks the field values on Transaction_Constrainable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_Constrainable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_Constrainable with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_ConstrainableMultiError, or nil if none found.
func (m *Transaction_Constrainable) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_Constrainable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_ConstrainableMultiError(errors)
	}

	return nil
}

// Transaction_ConstrainableMultiError is an error wrapping multiple validation
// errors returned by Transaction_Constrainable.ValidateAll() if the
// designated constraints aren't met.
type Transaction_ConstrainableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ConstrainableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ConstrainableMultiError) AllErrors() []error { return m }

// Transaction_ConstrainableValidationError is the validation error returned by
// Transaction_Constrainable.Validate if the designated constraints aren't met.
type Transaction_ConstrainableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ConstrainableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_ConstrainableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_ConstrainableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_ConstrainableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_ConstrainableValidationError) ErrorName() string {
	return "Transaction_ConstrainableValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ConstrainableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_Constrainable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ConstrainableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ConstrainableValidationError{}

// Validate checks the field values on Transaction_Administrable with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_Administrable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_Administrable with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_AdministrableMultiError, or nil if none found.
func (m *Transaction_Administrable) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_Administrable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_AdministrableMultiError(errors)
	}

	return nil
}

// Transaction_AdministrableMultiError is an error wrapping multiple validation
// errors returned by Transaction_Administrable.ValidateAll() if the
// designated constraints aren't met.
type Transaction_AdministrableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_AdministrableMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_AdministrableMultiError) AllErrors() []error { return m }

// Transaction_AdministrableValidationError is the validation error returned by
// Transaction_Administrable.Validate if the designated constraints aren't met.
type Transaction_AdministrableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_AdministrableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_AdministrableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_AdministrableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_AdministrableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_AdministrableValidationError) ErrorName() string {
	return "Transaction_AdministrableValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_AdministrableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_Administrable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_AdministrableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_AdministrableValidationError{}

// Validate checks the field values on
// Transaction_SpendingLimitsConstraintModule with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction_SpendingLimitsConstraintModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_SpendingLimitsConstraintModule with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// Transaction_SpendingLimitsConstraintModuleMultiError, or nil if none found.
func (m *Transaction_SpendingLimitsConstraintModule) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SpendingLimitsConstraintModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_SpendingLimitsConstraintModuleMultiError(errors)
	}

	return nil
}

// Transaction_SpendingLimitsConstraintModuleMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_SpendingLimitsConstraintModule.ValidateAll() if the designated
// constraints aren't met.
type Transaction_SpendingLimitsConstraintModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SpendingLimitsConstraintModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SpendingLimitsConstraintModuleMultiError) AllErrors() []error { return m }

// Transaction_SpendingLimitsConstraintModuleValidationError is the validation
// error returned by Transaction_SpendingLimitsConstraintModule.Validate if
// the designated constraints aren't met.
type Transaction_SpendingLimitsConstraintModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SpendingLimitsConstraintModuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_SpendingLimitsConstraintModuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_SpendingLimitsConstraintModuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_SpendingLimitsConstraintModuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_SpendingLimitsConstraintModuleValidationError) ErrorName() string {
	return "Transaction_SpendingLimitsConstraintModuleValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SpendingLimitsConstraintModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SpendingLimitsConstraintModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SpendingLimitsConstraintModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SpendingLimitsConstraintModuleValidationError{}

// Validate checks the field values on Transaction_TimeLockConstraintModule
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Transaction_TimeLockConstraintModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_TimeLockConstraintModule
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Transaction_TimeLockConstraintModuleMultiError, or nil if none found.
func (m *Transaction_TimeLockConstraintModule) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_TimeLockConstraintModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_TimeLockConstraintModuleMultiError(errors)
	}

	return nil
}

// Transaction_TimeLockConstraintModuleMultiError is an error wrapping multiple
// validation errors returned by
// Transaction_TimeLockConstraintModule.ValidateAll() if the designated
// constraints aren't met.
type Transaction_TimeLockConstraintModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_TimeLockConstraintModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_TimeLockConstraintModuleMultiError) AllErrors() []error { return m }

// Transaction_TimeLockConstraintModuleValidationError is the validation error
// returned by Transaction_TimeLockConstraintModule.Validate if the designated
// constraints aren't met.
type Transaction_TimeLockConstraintModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_TimeLockConstraintModuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_TimeLockConstraintModuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_TimeLockConstraintModuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_TimeLockConstraintModuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_TimeLockConstraintModuleValidationError) ErrorName() string {
	return "Transaction_TimeLockConstraintModuleValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_TimeLockConstraintModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_TimeLockConstraintModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_TimeLockConstraintModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_TimeLockConstraintModuleValidationError{}

// Validate checks the field values on
// Transaction_VestingPeriodConstraintModule with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction_VestingPeriodConstraintModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_VestingPeriodConstraintModule with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// Transaction_VestingPeriodConstraintModuleMultiError, or nil if none found.
func (m *Transaction_VestingPeriodConstraintModule) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_VestingPeriodConstraintModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_VestingPeriodConstraintModuleMultiError(errors)
	}

	return nil
}

// Transaction_VestingPeriodConstraintModuleMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_VestingPeriodConstraintModule.ValidateAll() if the designated
// constraints aren't met.
type Transaction_VestingPeriodConstraintModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_VestingPeriodConstraintModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_VestingPeriodConstraintModuleMultiError) AllErrors() []error { return m }

// Transaction_VestingPeriodConstraintModuleValidationError is the validation
// error returned by Transaction_VestingPeriodConstraintModule.Validate if the
// designated constraints aren't met.
type Transaction_VestingPeriodConstraintModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_VestingPeriodConstraintModuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_VestingPeriodConstraintModuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_VestingPeriodConstraintModuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_VestingPeriodConstraintModuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_VestingPeriodConstraintModuleValidationError) ErrorName() string {
	return "Transaction_VestingPeriodConstraintModuleValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_VestingPeriodConstraintModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_VestingPeriodConstraintModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_VestingPeriodConstraintModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_VestingPeriodConstraintModuleValidationError{}

// Validate checks the field values on Transaction_WhitelistConstraintModule
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Transaction_WhitelistConstraintModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_WhitelistConstraintModule
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Transaction_WhitelistConstraintModuleMultiError, or nil if none found.
func (m *Transaction_WhitelistConstraintModule) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_WhitelistConstraintModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_WhitelistConstraintModuleMultiError(errors)
	}

	return nil
}

// Transaction_WhitelistConstraintModuleMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_WhitelistConstraintModule.ValidateAll() if the designated
// constraints aren't met.
type Transaction_WhitelistConstraintModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_WhitelistConstraintModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_WhitelistConstraintModuleMultiError) AllErrors() []error { return m }

// Transaction_WhitelistConstraintModuleValidationError is the validation error
// returned by Transaction_WhitelistConstraintModule.Validate if the
// designated constraints aren't met.
type Transaction_WhitelistConstraintModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_WhitelistConstraintModuleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_WhitelistConstraintModuleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_WhitelistConstraintModuleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_WhitelistConstraintModuleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_WhitelistConstraintModuleValidationError) ErrorName() string {
	return "Transaction_WhitelistConstraintModuleValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_WhitelistConstraintModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_WhitelistConstraintModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_WhitelistConstraintModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_WhitelistConstraintModuleValidationError{}

// Validate checks the field values on Transaction_Metadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_Metadata) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_Metadata with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_MetadataMultiError, or nil if none found.
func (m *Transaction_Metadata) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_Metadata) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Hash

	if all {
		switch v := interface{}(m.GetDate()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Transaction_MetadataValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Transaction_MetadataValidationError{
					field:  "Date",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDate()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Transaction_MetadataValidationError{
				field:  "Date",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Reverted

	if len(errors) > 0 {
		return Transaction_MetadataMultiError(errors)
	}

	return nil
}

// Transaction_MetadataMultiError is an error wrapping multiple validation
// errors returned by Transaction_Metadata.ValidateAll() if the designated
// constraints aren't met.
type Transaction_MetadataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_MetadataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_MetadataMultiError) AllErrors() []error { return m }

// Transaction_MetadataValidationError is the validation error returned by
// Transaction_Metadata.Validate if the designated constraints aren't met.
type Transaction_MetadataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_MetadataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_MetadataValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_MetadataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_MetadataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_MetadataValidationError) ErrorName() string {
	return "Transaction_MetadataValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_MetadataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_Metadata.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_MetadataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_MetadataValidationError{}

// Validate checks the field values on
// Transaction_SecurityTokenFactory_DeployNewSecurityToken with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_SecurityTokenFactory_DeployNewSecurityToken) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_SecurityTokenFactory_DeployNewSecurityToken with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_SecurityTokenFactory_DeployNewSecurityTokenMultiError, or nil
// if none found.
func (m *Transaction_SecurityTokenFactory_DeployNewSecurityToken) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SecurityTokenFactory_DeployNewSecurityToken) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Symbol

	// no validation rules for Granularity

	// no validation rules for Cap

	// no validation rules for Admin

	// no validation rules for Controller

	// no validation rules for Issuer

	// no validation rules for Redeemer

	// no validation rules for ModuleEditor

	if len(errors) > 0 {
		return Transaction_SecurityTokenFactory_DeployNewSecurityTokenMultiError(errors)
	}

	return nil
}

// Transaction_SecurityTokenFactory_DeployNewSecurityTokenMultiError is an
// error wrapping multiple validation errors returned by
// Transaction_SecurityTokenFactory_DeployNewSecurityToken.ValidateAll() if
// the designated constraints aren't met.
type Transaction_SecurityTokenFactory_DeployNewSecurityTokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SecurityTokenFactory_DeployNewSecurityTokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SecurityTokenFactory_DeployNewSecurityTokenMultiError) AllErrors() []error {
	return m
}

// Transaction_SecurityTokenFactory_DeployNewSecurityTokenValidationError is
// the validation error returned by
// Transaction_SecurityTokenFactory_DeployNewSecurityToken.Validate if the
// designated constraints aren't met.
type Transaction_SecurityTokenFactory_DeployNewSecurityTokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SecurityTokenFactory_DeployNewSecurityTokenValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_SecurityTokenFactory_DeployNewSecurityTokenValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_SecurityTokenFactory_DeployNewSecurityTokenValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_SecurityTokenFactory_DeployNewSecurityTokenValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_SecurityTokenFactory_DeployNewSecurityTokenValidationError) ErrorName() string {
	return "Transaction_SecurityTokenFactory_DeployNewSecurityTokenValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SecurityTokenFactory_DeployNewSecurityTokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SecurityTokenFactory_DeployNewSecurityToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SecurityTokenFactory_DeployNewSecurityTokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SecurityTokenFactory_DeployNewSecurityTokenValidationError{}

// Validate checks the field values on
// Transaction_SecurityToken_BulkIssueByPartition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction_SecurityToken_BulkIssueByPartition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_SecurityToken_BulkIssueByPartition with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// Transaction_SecurityToken_BulkIssueByPartitionMultiError, or nil if none found.
func (m *Transaction_SecurityToken_BulkIssueByPartition) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SecurityToken_BulkIssueByPartition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Partition

	// no validation rules for Data

	if len(errors) > 0 {
		return Transaction_SecurityToken_BulkIssueByPartitionMultiError(errors)
	}

	return nil
}

// Transaction_SecurityToken_BulkIssueByPartitionMultiError is an error
// wrapping multiple validation errors returned by
// Transaction_SecurityToken_BulkIssueByPartition.ValidateAll() if the
// designated constraints aren't met.
type Transaction_SecurityToken_BulkIssueByPartitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SecurityToken_BulkIssueByPartitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SecurityToken_BulkIssueByPartitionMultiError) AllErrors() []error { return m }

// Transaction_SecurityToken_BulkIssueByPartitionValidationError is the
// validation error returned by
// Transaction_SecurityToken_BulkIssueByPartition.Validate if the designated
// constraints aren't met.
type Transaction_SecurityToken_BulkIssueByPartitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SecurityToken_BulkIssueByPartitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_SecurityToken_BulkIssueByPartitionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_SecurityToken_BulkIssueByPartitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_SecurityToken_BulkIssueByPartitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_SecurityToken_BulkIssueByPartitionValidationError) ErrorName() string {
	return "Transaction_SecurityToken_BulkIssueByPartitionValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SecurityToken_BulkIssueByPartitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SecurityToken_BulkIssueByPartition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SecurityToken_BulkIssueByPartitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SecurityToken_BulkIssueByPartitionValidationError{}

// Validate checks the field values on Transaction_SecurityToken_SetDocument
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Transaction_SecurityToken_SetDocument) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_SecurityToken_SetDocument
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Transaction_SecurityToken_SetDocumentMultiError, or nil if none found.
func (m *Transaction_SecurityToken_SetDocument) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SecurityToken_SetDocument) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DocumentName

	// no validation rules for Uri

	// no validation rules for DocumentHash

	if len(errors) > 0 {
		return Transaction_SecurityToken_SetDocumentMultiError(errors)
	}

	return nil
}

// Transaction_SecurityToken_SetDocumentMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_SecurityToken_SetDocument.ValidateAll() if the designated
// constraints aren't met.
type Transaction_SecurityToken_SetDocumentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SecurityToken_SetDocumentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SecurityToken_SetDocumentMultiError) AllErrors() []error { return m }

// Transaction_SecurityToken_SetDocumentValidationError is the validation error
// returned by Transaction_SecurityToken_SetDocument.Validate if the
// designated constraints aren't met.
type Transaction_SecurityToken_SetDocumentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SecurityToken_SetDocumentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_SecurityToken_SetDocumentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_SecurityToken_SetDocumentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_SecurityToken_SetDocumentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_SecurityToken_SetDocumentValidationError) ErrorName() string {
	return "Transaction_SecurityToken_SetDocumentValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SecurityToken_SetDocumentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SecurityToken_SetDocument.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SecurityToken_SetDocumentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SecurityToken_SetDocumentValidationError{}

// Validate checks the field values on
// Transaction_SecurityToken_IssueByPartition with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction_SecurityToken_IssueByPartition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_SecurityToken_IssueByPartition with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// Transaction_SecurityToken_IssueByPartitionMultiError, or nil if none found.
func (m *Transaction_SecurityToken_IssueByPartition) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SecurityToken_IssueByPartition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Partition

	// no validation rules for Recipient

	// no validation rules for Amount

	if len(errors) > 0 {
		return Transaction_SecurityToken_IssueByPartitionMultiError(errors)
	}

	return nil
}

// Transaction_SecurityToken_IssueByPartitionMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_SecurityToken_IssueByPartition.ValidateAll() if the designated
// constraints aren't met.
type Transaction_SecurityToken_IssueByPartitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SecurityToken_IssueByPartitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SecurityToken_IssueByPartitionMultiError) AllErrors() []error { return m }

// Transaction_SecurityToken_IssueByPartitionValidationError is the validation
// error returned by Transaction_SecurityToken_IssueByPartition.Validate if
// the designated constraints aren't met.
type Transaction_SecurityToken_IssueByPartitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SecurityToken_IssueByPartitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_SecurityToken_IssueByPartitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_SecurityToken_IssueByPartitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_SecurityToken_IssueByPartitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_SecurityToken_IssueByPartitionValidationError) ErrorName() string {
	return "Transaction_SecurityToken_IssueByPartitionValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SecurityToken_IssueByPartitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SecurityToken_IssueByPartition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SecurityToken_IssueByPartitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SecurityToken_IssueByPartitionValidationError{}

// Validate checks the field values on
// Transaction_SecurityToken_RedeemByPartition with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction_SecurityToken_RedeemByPartition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_SecurityToken_RedeemByPartition with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// Transaction_SecurityToken_RedeemByPartitionMultiError, or nil if none found.
func (m *Transaction_SecurityToken_RedeemByPartition) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SecurityToken_RedeemByPartition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Partition

	// no validation rules for Value

	// no validation rules for Data

	if len(errors) > 0 {
		return Transaction_SecurityToken_RedeemByPartitionMultiError(errors)
	}

	return nil
}

// Transaction_SecurityToken_RedeemByPartitionMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_SecurityToken_RedeemByPartition.ValidateAll() if the designated
// constraints aren't met.
type Transaction_SecurityToken_RedeemByPartitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SecurityToken_RedeemByPartitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SecurityToken_RedeemByPartitionMultiError) AllErrors() []error { return m }

// Transaction_SecurityToken_RedeemByPartitionValidationError is the validation
// error returned by Transaction_SecurityToken_RedeemByPartition.Validate if
// the designated constraints aren't met.
type Transaction_SecurityToken_RedeemByPartitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SecurityToken_RedeemByPartitionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_SecurityToken_RedeemByPartitionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_SecurityToken_RedeemByPartitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_SecurityToken_RedeemByPartitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_SecurityToken_RedeemByPartitionValidationError) ErrorName() string {
	return "Transaction_SecurityToken_RedeemByPartitionValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SecurityToken_RedeemByPartitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SecurityToken_RedeemByPartition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SecurityToken_RedeemByPartitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SecurityToken_RedeemByPartitionValidationError{}

// Validate checks the field values on
// Transaction_SecurityToken_OperatorRedeemByPartition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Transaction_SecurityToken_OperatorRedeemByPartition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_SecurityToken_OperatorRedeemByPartition with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// Transaction_SecurityToken_OperatorRedeemByPartitionMultiError, or nil if
// none found.
func (m *Transaction_SecurityToken_OperatorRedeemByPartition) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SecurityToken_OperatorRedeemByPartition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Partition

	// no validation rules for TokenHolder

	// no validation rules for Value

	// no validation rules for Data

	// no validation rules for OperatorData

	if len(errors) > 0 {
		return Transaction_SecurityToken_OperatorRedeemByPartitionMultiError(errors)
	}

	return nil
}

// Transaction_SecurityToken_OperatorRedeemByPartitionMultiError is an error
// wrapping multiple validation errors returned by
// Transaction_SecurityToken_OperatorRedeemByPartition.ValidateAll() if the
// designated constraints aren't met.
type Transaction_SecurityToken_OperatorRedeemByPartitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SecurityToken_OperatorRedeemByPartitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SecurityToken_OperatorRedeemByPartitionMultiError) AllErrors() []error { return m }

// Transaction_SecurityToken_OperatorRedeemByPartitionValidationError is the
// validation error returned by
// Transaction_SecurityToken_OperatorRedeemByPartition.Validate if the
// designated constraints aren't met.
type Transaction_SecurityToken_OperatorRedeemByPartitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SecurityToken_OperatorRedeemByPartitionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_SecurityToken_OperatorRedeemByPartitionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_SecurityToken_OperatorRedeemByPartitionValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_SecurityToken_OperatorRedeemByPartitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_SecurityToken_OperatorRedeemByPartitionValidationError) ErrorName() string {
	return "Transaction_SecurityToken_OperatorRedeemByPartitionValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SecurityToken_OperatorRedeemByPartitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SecurityToken_OperatorRedeemByPartition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SecurityToken_OperatorRedeemByPartitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SecurityToken_OperatorRedeemByPartitionValidationError{}

// Validate checks the field values on
// Transaction_SecurityToken_RenounceControl with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction_SecurityToken_RenounceControl) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_SecurityToken_RenounceControl with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// Transaction_SecurityToken_RenounceControlMultiError, or nil if none found.
func (m *Transaction_SecurityToken_RenounceControl) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SecurityToken_RenounceControl) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_SecurityToken_RenounceControlMultiError(errors)
	}

	return nil
}

// Transaction_SecurityToken_RenounceControlMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_SecurityToken_RenounceControl.ValidateAll() if the designated
// constraints aren't met.
type Transaction_SecurityToken_RenounceControlMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SecurityToken_RenounceControlMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SecurityToken_RenounceControlMultiError) AllErrors() []error { return m }

// Transaction_SecurityToken_RenounceControlValidationError is the validation
// error returned by Transaction_SecurityToken_RenounceControl.Validate if the
// designated constraints aren't met.
type Transaction_SecurityToken_RenounceControlValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SecurityToken_RenounceControlValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_SecurityToken_RenounceControlValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_SecurityToken_RenounceControlValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_SecurityToken_RenounceControlValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_SecurityToken_RenounceControlValidationError) ErrorName() string {
	return "Transaction_SecurityToken_RenounceControlValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SecurityToken_RenounceControlValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SecurityToken_RenounceControl.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SecurityToken_RenounceControlValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SecurityToken_RenounceControlValidationError{}

// Validate checks the field values on
// Transaction_SecurityToken_RenounceIssuance with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction_SecurityToken_RenounceIssuance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_SecurityToken_RenounceIssuance with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// Transaction_SecurityToken_RenounceIssuanceMultiError, or nil if none found.
func (m *Transaction_SecurityToken_RenounceIssuance) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SecurityToken_RenounceIssuance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_SecurityToken_RenounceIssuanceMultiError(errors)
	}

	return nil
}

// Transaction_SecurityToken_RenounceIssuanceMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_SecurityToken_RenounceIssuance.ValidateAll() if the designated
// constraints aren't met.
type Transaction_SecurityToken_RenounceIssuanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SecurityToken_RenounceIssuanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SecurityToken_RenounceIssuanceMultiError) AllErrors() []error { return m }

// Transaction_SecurityToken_RenounceIssuanceValidationError is the validation
// error returned by Transaction_SecurityToken_RenounceIssuance.Validate if
// the designated constraints aren't met.
type Transaction_SecurityToken_RenounceIssuanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SecurityToken_RenounceIssuanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_SecurityToken_RenounceIssuanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_SecurityToken_RenounceIssuanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_SecurityToken_RenounceIssuanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_SecurityToken_RenounceIssuanceValidationError) ErrorName() string {
	return "Transaction_SecurityToken_RenounceIssuanceValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SecurityToken_RenounceIssuanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SecurityToken_RenounceIssuance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SecurityToken_RenounceIssuanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SecurityToken_RenounceIssuanceValidationError{}

// Validate checks the field values on Transaction_Pausable_Pause with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_Pausable_Pause) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_Pausable_Pause with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_Pausable_PauseMultiError, or nil if none found.
func (m *Transaction_Pausable_Pause) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_Pausable_Pause) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_Pausable_PauseMultiError(errors)
	}

	return nil
}

// Transaction_Pausable_PauseMultiError is an error wrapping multiple
// validation errors returned by Transaction_Pausable_Pause.ValidateAll() if
// the designated constraints aren't met.
type Transaction_Pausable_PauseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_Pausable_PauseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_Pausable_PauseMultiError) AllErrors() []error { return m }

// Transaction_Pausable_PauseValidationError is the validation error returned
// by Transaction_Pausable_Pause.Validate if the designated constraints aren't met.
type Transaction_Pausable_PauseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_Pausable_PauseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_Pausable_PauseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_Pausable_PauseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_Pausable_PauseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_Pausable_PauseValidationError) ErrorName() string {
	return "Transaction_Pausable_PauseValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_Pausable_PauseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_Pausable_Pause.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_Pausable_PauseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_Pausable_PauseValidationError{}

// Validate checks the field values on Transaction_Pausable_Unpause with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_Pausable_Unpause) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_Pausable_Unpause with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_Pausable_UnpauseMultiError, or nil if none found.
func (m *Transaction_Pausable_Unpause) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_Pausable_Unpause) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_Pausable_UnpauseMultiError(errors)
	}

	return nil
}

// Transaction_Pausable_UnpauseMultiError is an error wrapping multiple
// validation errors returned by Transaction_Pausable_Unpause.ValidateAll() if
// the designated constraints aren't met.
type Transaction_Pausable_UnpauseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_Pausable_UnpauseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_Pausable_UnpauseMultiError) AllErrors() []error { return m }

// Transaction_Pausable_UnpauseValidationError is the validation error returned
// by Transaction_Pausable_Unpause.Validate if the designated constraints
// aren't met.
type Transaction_Pausable_UnpauseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_Pausable_UnpauseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_Pausable_UnpauseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_Pausable_UnpauseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_Pausable_UnpauseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_Pausable_UnpauseValidationError) ErrorName() string {
	return "Transaction_Pausable_UnpauseValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_Pausable_UnpauseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_Pausable_Unpause.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_Pausable_UnpauseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_Pausable_UnpauseValidationError{}

// Validate checks the field values on Transaction_Ownable_TransferOwnership
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Transaction_Ownable_TransferOwnership) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_Ownable_TransferOwnership
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Transaction_Ownable_TransferOwnershipMultiError, or nil if none found.
func (m *Transaction_Ownable_TransferOwnership) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_Ownable_TransferOwnership) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NewOwner

	if len(errors) > 0 {
		return Transaction_Ownable_TransferOwnershipMultiError(errors)
	}

	return nil
}

// Transaction_Ownable_TransferOwnershipMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_Ownable_TransferOwnership.ValidateAll() if the designated
// constraints aren't met.
type Transaction_Ownable_TransferOwnershipMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_Ownable_TransferOwnershipMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_Ownable_TransferOwnershipMultiError) AllErrors() []error { return m }

// Transaction_Ownable_TransferOwnershipValidationError is the validation error
// returned by Transaction_Ownable_TransferOwnership.Validate if the
// designated constraints aren't met.
type Transaction_Ownable_TransferOwnershipValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_Ownable_TransferOwnershipValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_Ownable_TransferOwnershipValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_Ownable_TransferOwnershipValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_Ownable_TransferOwnershipValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_Ownable_TransferOwnershipValidationError) ErrorName() string {
	return "Transaction_Ownable_TransferOwnershipValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_Ownable_TransferOwnershipValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_Ownable_TransferOwnership.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_Ownable_TransferOwnershipValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_Ownable_TransferOwnershipValidationError{}

// Validate checks the field values on Transaction_ERC1400Raw_AuthorizeOperator
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Transaction_ERC1400Raw_AuthorizeOperator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_ERC1400Raw_AuthorizeOperator with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// Transaction_ERC1400Raw_AuthorizeOperatorMultiError, or nil if none found.
func (m *Transaction_ERC1400Raw_AuthorizeOperator) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400Raw_AuthorizeOperator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Operator

	if len(errors) > 0 {
		return Transaction_ERC1400Raw_AuthorizeOperatorMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400Raw_AuthorizeOperatorMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_ERC1400Raw_AuthorizeOperator.ValidateAll() if the designated
// constraints aren't met.
type Transaction_ERC1400Raw_AuthorizeOperatorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400Raw_AuthorizeOperatorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400Raw_AuthorizeOperatorMultiError) AllErrors() []error { return m }

// Transaction_ERC1400Raw_AuthorizeOperatorValidationError is the validation
// error returned by Transaction_ERC1400Raw_AuthorizeOperator.Validate if the
// designated constraints aren't met.
type Transaction_ERC1400Raw_AuthorizeOperatorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400Raw_AuthorizeOperatorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_ERC1400Raw_AuthorizeOperatorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_ERC1400Raw_AuthorizeOperatorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_ERC1400Raw_AuthorizeOperatorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_ERC1400Raw_AuthorizeOperatorValidationError) ErrorName() string {
	return "Transaction_ERC1400Raw_AuthorizeOperatorValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400Raw_AuthorizeOperatorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400Raw_AuthorizeOperator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400Raw_AuthorizeOperatorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400Raw_AuthorizeOperatorValidationError{}

// Validate checks the field values on Transaction_ERC1400Raw_RevokeOperator
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Transaction_ERC1400Raw_RevokeOperator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_ERC1400Raw_RevokeOperator
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Transaction_ERC1400Raw_RevokeOperatorMultiError, or nil if none found.
func (m *Transaction_ERC1400Raw_RevokeOperator) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400Raw_RevokeOperator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Operator

	if len(errors) > 0 {
		return Transaction_ERC1400Raw_RevokeOperatorMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400Raw_RevokeOperatorMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_ERC1400Raw_RevokeOperator.ValidateAll() if the designated
// constraints aren't met.
type Transaction_ERC1400Raw_RevokeOperatorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400Raw_RevokeOperatorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400Raw_RevokeOperatorMultiError) AllErrors() []error { return m }

// Transaction_ERC1400Raw_RevokeOperatorValidationError is the validation error
// returned by Transaction_ERC1400Raw_RevokeOperator.Validate if the
// designated constraints aren't met.
type Transaction_ERC1400Raw_RevokeOperatorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400Raw_RevokeOperatorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_ERC1400Raw_RevokeOperatorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_ERC1400Raw_RevokeOperatorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_ERC1400Raw_RevokeOperatorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_ERC1400Raw_RevokeOperatorValidationError) ErrorName() string {
	return "Transaction_ERC1400Raw_RevokeOperatorValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400Raw_RevokeOperatorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400Raw_RevokeOperator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400Raw_RevokeOperatorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400Raw_RevokeOperatorValidationError{}

// Validate checks the field values on
// Transaction_ERC1400Partition_TransferByPartition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction_ERC1400Partition_TransferByPartition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_ERC1400Partition_TransferByPartition with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// Transaction_ERC1400Partition_TransferByPartitionMultiError, or nil if none found.
func (m *Transaction_ERC1400Partition_TransferByPartition) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400Partition_TransferByPartition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Partition

	// no validation rules for To

	// no validation rules for Value

	// no validation rules for Calldata

	if len(errors) > 0 {
		return Transaction_ERC1400Partition_TransferByPartitionMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400Partition_TransferByPartitionMultiError is an error
// wrapping multiple validation errors returned by
// Transaction_ERC1400Partition_TransferByPartition.ValidateAll() if the
// designated constraints aren't met.
type Transaction_ERC1400Partition_TransferByPartitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400Partition_TransferByPartitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400Partition_TransferByPartitionMultiError) AllErrors() []error { return m }

// Transaction_ERC1400Partition_TransferByPartitionValidationError is the
// validation error returned by
// Transaction_ERC1400Partition_TransferByPartition.Validate if the designated
// constraints aren't met.
type Transaction_ERC1400Partition_TransferByPartitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400Partition_TransferByPartitionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_ERC1400Partition_TransferByPartitionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_ERC1400Partition_TransferByPartitionValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_ERC1400Partition_TransferByPartitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_ERC1400Partition_TransferByPartitionValidationError) ErrorName() string {
	return "Transaction_ERC1400Partition_TransferByPartitionValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400Partition_TransferByPartitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400Partition_TransferByPartition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400Partition_TransferByPartitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400Partition_TransferByPartitionValidationError{}

// Validate checks the field values on
// Transaction_ERC1400Partition_OperatorTransferByPartition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_ERC1400Partition_OperatorTransferByPartition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_ERC1400Partition_OperatorTransferByPartition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_ERC1400Partition_OperatorTransferByPartitionMultiError, or nil
// if none found.
func (m *Transaction_ERC1400Partition_OperatorTransferByPartition) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400Partition_OperatorTransferByPartition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Partition

	// no validation rules for From

	// no validation rules for To

	// no validation rules for Value

	// no validation rules for Data

	// no validation rules for OperatorData

	if len(errors) > 0 {
		return Transaction_ERC1400Partition_OperatorTransferByPartitionMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400Partition_OperatorTransferByPartitionMultiError is an
// error wrapping multiple validation errors returned by
// Transaction_ERC1400Partition_OperatorTransferByPartition.ValidateAll() if
// the designated constraints aren't met.
type Transaction_ERC1400Partition_OperatorTransferByPartitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400Partition_OperatorTransferByPartitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400Partition_OperatorTransferByPartitionMultiError) AllErrors() []error {
	return m
}

// Transaction_ERC1400Partition_OperatorTransferByPartitionValidationError is
// the validation error returned by
// Transaction_ERC1400Partition_OperatorTransferByPartition.Validate if the
// designated constraints aren't met.
type Transaction_ERC1400Partition_OperatorTransferByPartitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400Partition_OperatorTransferByPartitionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_ERC1400Partition_OperatorTransferByPartitionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_ERC1400Partition_OperatorTransferByPartitionValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_ERC1400Partition_OperatorTransferByPartitionValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_ERC1400Partition_OperatorTransferByPartitionValidationError) ErrorName() string {
	return "Transaction_ERC1400Partition_OperatorTransferByPartitionValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400Partition_OperatorTransferByPartitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400Partition_OperatorTransferByPartition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400Partition_OperatorTransferByPartitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400Partition_OperatorTransferByPartitionValidationError{}

// Validate checks the field values on
// Transaction_ERC1400Partition_AuthorizeOperatorByPartition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_ERC1400Partition_AuthorizeOperatorByPartition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_ERC1400Partition_AuthorizeOperatorByPartition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_ERC1400Partition_AuthorizeOperatorByPartitionMultiError, or nil
// if none found.
func (m *Transaction_ERC1400Partition_AuthorizeOperatorByPartition) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400Partition_AuthorizeOperatorByPartition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Partition

	// no validation rules for Operator

	if len(errors) > 0 {
		return Transaction_ERC1400Partition_AuthorizeOperatorByPartitionMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400Partition_AuthorizeOperatorByPartitionMultiError is an
// error wrapping multiple validation errors returned by
// Transaction_ERC1400Partition_AuthorizeOperatorByPartition.ValidateAll() if
// the designated constraints aren't met.
type Transaction_ERC1400Partition_AuthorizeOperatorByPartitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400Partition_AuthorizeOperatorByPartitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400Partition_AuthorizeOperatorByPartitionMultiError) AllErrors() []error {
	return m
}

// Transaction_ERC1400Partition_AuthorizeOperatorByPartitionValidationError is
// the validation error returned by
// Transaction_ERC1400Partition_AuthorizeOperatorByPartition.Validate if the
// designated constraints aren't met.
type Transaction_ERC1400Partition_AuthorizeOperatorByPartitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400Partition_AuthorizeOperatorByPartitionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_ERC1400Partition_AuthorizeOperatorByPartitionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_ERC1400Partition_AuthorizeOperatorByPartitionValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_ERC1400Partition_AuthorizeOperatorByPartitionValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_ERC1400Partition_AuthorizeOperatorByPartitionValidationError) ErrorName() string {
	return "Transaction_ERC1400Partition_AuthorizeOperatorByPartitionValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400Partition_AuthorizeOperatorByPartitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400Partition_AuthorizeOperatorByPartition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400Partition_AuthorizeOperatorByPartitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400Partition_AuthorizeOperatorByPartitionValidationError{}

// Validate checks the field values on
// Transaction_ERC1400Partition_RevokeOperatorByPartition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_ERC1400Partition_RevokeOperatorByPartition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_ERC1400Partition_RevokeOperatorByPartition with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_ERC1400Partition_RevokeOperatorByPartitionMultiError, or nil if
// none found.
func (m *Transaction_ERC1400Partition_RevokeOperatorByPartition) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400Partition_RevokeOperatorByPartition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Partition

	// no validation rules for Operator

	if len(errors) > 0 {
		return Transaction_ERC1400Partition_RevokeOperatorByPartitionMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400Partition_RevokeOperatorByPartitionMultiError is an error
// wrapping multiple validation errors returned by
// Transaction_ERC1400Partition_RevokeOperatorByPartition.ValidateAll() if the
// designated constraints aren't met.
type Transaction_ERC1400Partition_RevokeOperatorByPartitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400Partition_RevokeOperatorByPartitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400Partition_RevokeOperatorByPartitionMultiError) AllErrors() []error {
	return m
}

// Transaction_ERC1400Partition_RevokeOperatorByPartitionValidationError is the
// validation error returned by
// Transaction_ERC1400Partition_RevokeOperatorByPartition.Validate if the
// designated constraints aren't met.
type Transaction_ERC1400Partition_RevokeOperatorByPartitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400Partition_RevokeOperatorByPartitionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_ERC1400Partition_RevokeOperatorByPartitionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_ERC1400Partition_RevokeOperatorByPartitionValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_ERC1400Partition_RevokeOperatorByPartitionValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_ERC1400Partition_RevokeOperatorByPartitionValidationError) ErrorName() string {
	return "Transaction_ERC1400Partition_RevokeOperatorByPartitionValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400Partition_RevokeOperatorByPartitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400Partition_RevokeOperatorByPartition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400Partition_RevokeOperatorByPartitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400Partition_RevokeOperatorByPartitionValidationError{}

// Validate checks the field values on
// Transaction_ERC1400Partition_TransferWithData with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction_ERC1400Partition_TransferWithData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_ERC1400Partition_TransferWithData with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// Transaction_ERC1400Partition_TransferWithDataMultiError, or nil if none found.
func (m *Transaction_ERC1400Partition_TransferWithData) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400Partition_TransferWithData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for To

	// no validation rules for Value

	// no validation rules for Data

	if len(errors) > 0 {
		return Transaction_ERC1400Partition_TransferWithDataMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400Partition_TransferWithDataMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_ERC1400Partition_TransferWithData.ValidateAll() if the
// designated constraints aren't met.
type Transaction_ERC1400Partition_TransferWithDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400Partition_TransferWithDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400Partition_TransferWithDataMultiError) AllErrors() []error { return m }

// Transaction_ERC1400Partition_TransferWithDataValidationError is the
// validation error returned by
// Transaction_ERC1400Partition_TransferWithData.Validate if the designated
// constraints aren't met.
type Transaction_ERC1400Partition_TransferWithDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400Partition_TransferWithDataValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_ERC1400Partition_TransferWithDataValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_ERC1400Partition_TransferWithDataValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_ERC1400Partition_TransferWithDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_ERC1400Partition_TransferWithDataValidationError) ErrorName() string {
	return "Transaction_ERC1400Partition_TransferWithDataValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400Partition_TransferWithDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400Partition_TransferWithData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400Partition_TransferWithDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400Partition_TransferWithDataValidationError{}

// Validate checks the field values on
// Transaction_ERC1400Partition_TransferFromWithData with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction_ERC1400Partition_TransferFromWithData) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_ERC1400Partition_TransferFromWithData with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// Transaction_ERC1400Partition_TransferFromWithDataMultiError, or nil if none found.
func (m *Transaction_ERC1400Partition_TransferFromWithData) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400Partition_TransferFromWithData) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	// no validation rules for To

	// no validation rules for Value

	// no validation rules for Data

	// no validation rules for OperatorData

	if len(errors) > 0 {
		return Transaction_ERC1400Partition_TransferFromWithDataMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400Partition_TransferFromWithDataMultiError is an error
// wrapping multiple validation errors returned by
// Transaction_ERC1400Partition_TransferFromWithData.ValidateAll() if the
// designated constraints aren't met.
type Transaction_ERC1400Partition_TransferFromWithDataMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400Partition_TransferFromWithDataMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400Partition_TransferFromWithDataMultiError) AllErrors() []error { return m }

// Transaction_ERC1400Partition_TransferFromWithDataValidationError is the
// validation error returned by
// Transaction_ERC1400Partition_TransferFromWithData.Validate if the
// designated constraints aren't met.
type Transaction_ERC1400Partition_TransferFromWithDataValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400Partition_TransferFromWithDataValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_ERC1400Partition_TransferFromWithDataValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_ERC1400Partition_TransferFromWithDataValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_ERC1400Partition_TransferFromWithDataValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_ERC1400Partition_TransferFromWithDataValidationError) ErrorName() string {
	return "Transaction_ERC1400Partition_TransferFromWithDataValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400Partition_TransferFromWithDataValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400Partition_TransferFromWithData.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400Partition_TransferFromWithDataValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400Partition_TransferFromWithDataValidationError{}

// Validate checks the field values on Transaction_ERC1400ERC20_Transfer with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *Transaction_ERC1400ERC20_Transfer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_ERC1400ERC20_Transfer
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Transaction_ERC1400ERC20_TransferMultiError, or nil if none found.
func (m *Transaction_ERC1400ERC20_Transfer) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400ERC20_Transfer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for To

	// no validation rules for Value

	if len(errors) > 0 {
		return Transaction_ERC1400ERC20_TransferMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400ERC20_TransferMultiError is an error wrapping multiple
// validation errors returned by
// Transaction_ERC1400ERC20_Transfer.ValidateAll() if the designated
// constraints aren't met.
type Transaction_ERC1400ERC20_TransferMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400ERC20_TransferMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400ERC20_TransferMultiError) AllErrors() []error { return m }

// Transaction_ERC1400ERC20_TransferValidationError is the validation error
// returned by Transaction_ERC1400ERC20_Transfer.Validate if the designated
// constraints aren't met.
type Transaction_ERC1400ERC20_TransferValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400ERC20_TransferValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_ERC1400ERC20_TransferValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_ERC1400ERC20_TransferValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_ERC1400ERC20_TransferValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_ERC1400ERC20_TransferValidationError) ErrorName() string {
	return "Transaction_ERC1400ERC20_TransferValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400ERC20_TransferValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400ERC20_Transfer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400ERC20_TransferValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400ERC20_TransferValidationError{}

// Validate checks the field values on Transaction_ERC1400ERC20_Approve with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *Transaction_ERC1400ERC20_Approve) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_ERC1400ERC20_Approve with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Transaction_ERC1400ERC20_ApproveMultiError, or nil if none found.
func (m *Transaction_ERC1400ERC20_Approve) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400ERC20_Approve) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Spender

	// no validation rules for Value

	if len(errors) > 0 {
		return Transaction_ERC1400ERC20_ApproveMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400ERC20_ApproveMultiError is an error wrapping multiple
// validation errors returned by
// Transaction_ERC1400ERC20_Approve.ValidateAll() if the designated
// constraints aren't met.
type Transaction_ERC1400ERC20_ApproveMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400ERC20_ApproveMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400ERC20_ApproveMultiError) AllErrors() []error { return m }

// Transaction_ERC1400ERC20_ApproveValidationError is the validation error
// returned by Transaction_ERC1400ERC20_Approve.Validate if the designated
// constraints aren't met.
type Transaction_ERC1400ERC20_ApproveValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400ERC20_ApproveValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_ERC1400ERC20_ApproveValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_ERC1400ERC20_ApproveValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_ERC1400ERC20_ApproveValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_ERC1400ERC20_ApproveValidationError) ErrorName() string {
	return "Transaction_ERC1400ERC20_ApproveValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400ERC20_ApproveValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400ERC20_Approve.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400ERC20_ApproveValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400ERC20_ApproveValidationError{}

// Validate checks the field values on Transaction_ERC1400ERC20_TransferFrom
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Transaction_ERC1400ERC20_TransferFrom) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_ERC1400ERC20_TransferFrom
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Transaction_ERC1400ERC20_TransferFromMultiError, or nil if none found.
func (m *Transaction_ERC1400ERC20_TransferFrom) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400ERC20_TransferFrom) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for From

	// no validation rules for To

	// no validation rules for Value

	if len(errors) > 0 {
		return Transaction_ERC1400ERC20_TransferFromMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400ERC20_TransferFromMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_ERC1400ERC20_TransferFrom.ValidateAll() if the designated
// constraints aren't met.
type Transaction_ERC1400ERC20_TransferFromMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400ERC20_TransferFromMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400ERC20_TransferFromMultiError) AllErrors() []error { return m }

// Transaction_ERC1400ERC20_TransferFromValidationError is the validation error
// returned by Transaction_ERC1400ERC20_TransferFrom.Validate if the
// designated constraints aren't met.
type Transaction_ERC1400ERC20_TransferFromValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400ERC20_TransferFromValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_ERC1400ERC20_TransferFromValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_ERC1400ERC20_TransferFromValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_ERC1400ERC20_TransferFromValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_ERC1400ERC20_TransferFromValidationError) ErrorName() string {
	return "Transaction_ERC1400ERC20_TransferFromValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400ERC20_TransferFromValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400ERC20_TransferFrom.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400ERC20_TransferFromValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400ERC20_TransferFromValidationError{}

// Validate checks the field values on Transaction_ERC1400Capped_SetCap with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *Transaction_ERC1400Capped_SetCap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_ERC1400Capped_SetCap with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Transaction_ERC1400Capped_SetCapMultiError, or nil if none found.
func (m *Transaction_ERC1400Capped_SetCap) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_ERC1400Capped_SetCap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for NewCap

	if len(errors) > 0 {
		return Transaction_ERC1400Capped_SetCapMultiError(errors)
	}

	return nil
}

// Transaction_ERC1400Capped_SetCapMultiError is an error wrapping multiple
// validation errors returned by
// Transaction_ERC1400Capped_SetCap.ValidateAll() if the designated
// constraints aren't met.
type Transaction_ERC1400Capped_SetCapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_ERC1400Capped_SetCapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_ERC1400Capped_SetCapMultiError) AllErrors() []error { return m }

// Transaction_ERC1400Capped_SetCapValidationError is the validation error
// returned by Transaction_ERC1400Capped_SetCap.Validate if the designated
// constraints aren't met.
type Transaction_ERC1400Capped_SetCapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_ERC1400Capped_SetCapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_ERC1400Capped_SetCapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_ERC1400Capped_SetCapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_ERC1400Capped_SetCapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_ERC1400Capped_SetCapValidationError) ErrorName() string {
	return "Transaction_ERC1400Capped_SetCapValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_ERC1400Capped_SetCapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_ERC1400Capped_SetCap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_ERC1400Capped_SetCapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_ERC1400Capped_SetCapValidationError{}

// Validate checks the field values on
// Transaction_Constrainable_SetModulesByPartition with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction_Constrainable_SetModulesByPartition) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_Constrainable_SetModulesByPartition with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// Transaction_Constrainable_SetModulesByPartitionMultiError, or nil if none found.
func (m *Transaction_Constrainable_SetModulesByPartition) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_Constrainable_SetModulesByPartition) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Partition

	if len(errors) > 0 {
		return Transaction_Constrainable_SetModulesByPartitionMultiError(errors)
	}

	return nil
}

// Transaction_Constrainable_SetModulesByPartitionMultiError is an error
// wrapping multiple validation errors returned by
// Transaction_Constrainable_SetModulesByPartition.ValidateAll() if the
// designated constraints aren't met.
type Transaction_Constrainable_SetModulesByPartitionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_Constrainable_SetModulesByPartitionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_Constrainable_SetModulesByPartitionMultiError) AllErrors() []error { return m }

// Transaction_Constrainable_SetModulesByPartitionValidationError is the
// validation error returned by
// Transaction_Constrainable_SetModulesByPartition.Validate if the designated
// constraints aren't met.
type Transaction_Constrainable_SetModulesByPartitionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_Constrainable_SetModulesByPartitionValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_Constrainable_SetModulesByPartitionValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_Constrainable_SetModulesByPartitionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_Constrainable_SetModulesByPartitionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_Constrainable_SetModulesByPartitionValidationError) ErrorName() string {
	return "Transaction_Constrainable_SetModulesByPartitionValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_Constrainable_SetModulesByPartitionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_Constrainable_SetModulesByPartition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_Constrainable_SetModulesByPartitionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_Constrainable_SetModulesByPartitionValidationError{}

// Validate checks the field values on Transaction_Administrable_AddRole with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *Transaction_Administrable_AddRole) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_Administrable_AddRole
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Transaction_Administrable_AddRoleMultiError, or nil if none found.
func (m *Transaction_Administrable_AddRole) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_Administrable_AddRole) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Role

	// no validation rules for Account

	if len(errors) > 0 {
		return Transaction_Administrable_AddRoleMultiError(errors)
	}

	return nil
}

// Transaction_Administrable_AddRoleMultiError is an error wrapping multiple
// validation errors returned by
// Transaction_Administrable_AddRole.ValidateAll() if the designated
// constraints aren't met.
type Transaction_Administrable_AddRoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_Administrable_AddRoleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_Administrable_AddRoleMultiError) AllErrors() []error { return m }

// Transaction_Administrable_AddRoleValidationError is the validation error
// returned by Transaction_Administrable_AddRole.Validate if the designated
// constraints aren't met.
type Transaction_Administrable_AddRoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_Administrable_AddRoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_Administrable_AddRoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_Administrable_AddRoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_Administrable_AddRoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_Administrable_AddRoleValidationError) ErrorName() string {
	return "Transaction_Administrable_AddRoleValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_Administrable_AddRoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_Administrable_AddRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_Administrable_AddRoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_Administrable_AddRoleValidationError{}

// Validate checks the field values on Transaction_Administrable_BulkAddRole
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Transaction_Administrable_BulkAddRole) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_Administrable_BulkAddRole
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Transaction_Administrable_BulkAddRoleMultiError, or nil if none found.
func (m *Transaction_Administrable_BulkAddRole) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_Administrable_BulkAddRole) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return Transaction_Administrable_BulkAddRoleMultiError(errors)
	}

	return nil
}

// Transaction_Administrable_BulkAddRoleMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_Administrable_BulkAddRole.ValidateAll() if the designated
// constraints aren't met.
type Transaction_Administrable_BulkAddRoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_Administrable_BulkAddRoleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_Administrable_BulkAddRoleMultiError) AllErrors() []error { return m }

// Transaction_Administrable_BulkAddRoleValidationError is the validation error
// returned by Transaction_Administrable_BulkAddRole.Validate if the
// designated constraints aren't met.
type Transaction_Administrable_BulkAddRoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_Administrable_BulkAddRoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_Administrable_BulkAddRoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_Administrable_BulkAddRoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_Administrable_BulkAddRoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_Administrable_BulkAddRoleValidationError) ErrorName() string {
	return "Transaction_Administrable_BulkAddRoleValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_Administrable_BulkAddRoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_Administrable_BulkAddRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_Administrable_BulkAddRoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_Administrable_BulkAddRoleValidationError{}

// Validate checks the field values on Transaction_Administrable_RemoveRole
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Transaction_Administrable_RemoveRole) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction_Administrable_RemoveRole
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Transaction_Administrable_RemoveRoleMultiError, or nil if none found.
func (m *Transaction_Administrable_RemoveRole) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_Administrable_RemoveRole) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Role

	// no validation rules for Account

	if len(errors) > 0 {
		return Transaction_Administrable_RemoveRoleMultiError(errors)
	}

	return nil
}

// Transaction_Administrable_RemoveRoleMultiError is an error wrapping multiple
// validation errors returned by
// Transaction_Administrable_RemoveRole.ValidateAll() if the designated
// constraints aren't met.
type Transaction_Administrable_RemoveRoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_Administrable_RemoveRoleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_Administrable_RemoveRoleMultiError) AllErrors() []error { return m }

// Transaction_Administrable_RemoveRoleValidationError is the validation error
// returned by Transaction_Administrable_RemoveRole.Validate if the designated
// constraints aren't met.
type Transaction_Administrable_RemoveRoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_Administrable_RemoveRoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_Administrable_RemoveRoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_Administrable_RemoveRoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_Administrable_RemoveRoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_Administrable_RemoveRoleValidationError) ErrorName() string {
	return "Transaction_Administrable_RemoveRoleValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_Administrable_RemoveRoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_Administrable_RemoveRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_Administrable_RemoveRoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_Administrable_RemoveRoleValidationError{}

// Validate checks the field values on Transaction_Administrable_RenounceRole
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Transaction_Administrable_RenounceRole) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_Administrable_RenounceRole with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// Transaction_Administrable_RenounceRoleMultiError, or nil if none found.
func (m *Transaction_Administrable_RenounceRole) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_Administrable_RenounceRole) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Role

	if len(errors) > 0 {
		return Transaction_Administrable_RenounceRoleMultiError(errors)
	}

	return nil
}

// Transaction_Administrable_RenounceRoleMultiError is an error wrapping
// multiple validation errors returned by
// Transaction_Administrable_RenounceRole.ValidateAll() if the designated
// constraints aren't met.
type Transaction_Administrable_RenounceRoleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_Administrable_RenounceRoleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_Administrable_RenounceRoleMultiError) AllErrors() []error { return m }

// Transaction_Administrable_RenounceRoleValidationError is the validation
// error returned by Transaction_Administrable_RenounceRole.Validate if the
// designated constraints aren't met.
type Transaction_Administrable_RenounceRoleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_Administrable_RenounceRoleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Transaction_Administrable_RenounceRoleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Transaction_Administrable_RenounceRoleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Transaction_Administrable_RenounceRoleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_Administrable_RenounceRoleValidationError) ErrorName() string {
	return "Transaction_Administrable_RenounceRoleValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_Administrable_RenounceRoleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_Administrable_RenounceRole.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_Administrable_RenounceRoleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_Administrable_RenounceRoleValidationError{}

// Validate checks the field values on
// Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModule
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModule
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleMultiError,
// or nil if none found.
func (m *Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModule) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TokenAddress

	if len(errors) > 0 {
		return Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleMultiError(errors)
	}

	return nil
}

// Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleMultiError
// is an error wrapping multiple validation errors returned by
// Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModule.ValidateAll()
// if the designated constraints aren't met.
type Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleMultiError) AllErrors() []error {
	return m
}

// Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleValidationError
// is the validation error returned by
// Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModule.Validate
// if the designated constraints aren't met.
type Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleValidationError) ErrorName() string {
	return "Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SpendingLimitsConstraintModule_DeploySpendingLimitsConstraintModuleValidationError{}

// Validate checks the field values on
// Transaction_SpendingLimitsConstraintModule_AddTimelock with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_SpendingLimitsConstraintModule_AddTimelock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_SpendingLimitsConstraintModule_AddTimelock with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_SpendingLimitsConstraintModule_AddTimelockMultiError, or nil if
// none found.
func (m *Transaction_SpendingLimitsConstraintModule_AddTimelock) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SpendingLimitsConstraintModule_AddTimelock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPeriodLength()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Transaction_SpendingLimitsConstraintModule_AddTimelockValidationError{
					field:  "PeriodLength",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Transaction_SpendingLimitsConstraintModule_AddTimelockValidationError{
					field:  "PeriodLength",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPeriodLength()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Transaction_SpendingLimitsConstraintModule_AddTimelockValidationError{
				field:  "PeriodLength",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AmountAllowed

	if len(errors) > 0 {
		return Transaction_SpendingLimitsConstraintModule_AddTimelockMultiError(errors)
	}

	return nil
}

// Transaction_SpendingLimitsConstraintModule_AddTimelockMultiError is an error
// wrapping multiple validation errors returned by
// Transaction_SpendingLimitsConstraintModule_AddTimelock.ValidateAll() if the
// designated constraints aren't met.
type Transaction_SpendingLimitsConstraintModule_AddTimelockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SpendingLimitsConstraintModule_AddTimelockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SpendingLimitsConstraintModule_AddTimelockMultiError) AllErrors() []error {
	return m
}

// Transaction_SpendingLimitsConstraintModule_AddTimelockValidationError is the
// validation error returned by
// Transaction_SpendingLimitsConstraintModule_AddTimelock.Validate if the
// designated constraints aren't met.
type Transaction_SpendingLimitsConstraintModule_AddTimelockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SpendingLimitsConstraintModule_AddTimelockValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_SpendingLimitsConstraintModule_AddTimelockValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_SpendingLimitsConstraintModule_AddTimelockValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_SpendingLimitsConstraintModule_AddTimelockValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_SpendingLimitsConstraintModule_AddTimelockValidationError) ErrorName() string {
	return "Transaction_SpendingLimitsConstraintModule_AddTimelockValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SpendingLimitsConstraintModule_AddTimelockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SpendingLimitsConstraintModule_AddTimelock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SpendingLimitsConstraintModule_AddTimelockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SpendingLimitsConstraintModule_AddTimelockValidationError{}

// Validate checks the field values on
// Transaction_SpendingLimitsConstraintModule_SetTimelock with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_SpendingLimitsConstraintModule_SetTimelock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_SpendingLimitsConstraintModule_SetTimelock with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_SpendingLimitsConstraintModule_SetTimelockMultiError, or nil if
// none found.
func (m *Transaction_SpendingLimitsConstraintModule_SetTimelock) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SpendingLimitsConstraintModule_SetTimelock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	if all {
		switch v := interface{}(m.GetPeriodLength()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Transaction_SpendingLimitsConstraintModule_SetTimelockValidationError{
					field:  "PeriodLength",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Transaction_SpendingLimitsConstraintModule_SetTimelockValidationError{
					field:  "PeriodLength",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPeriodLength()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Transaction_SpendingLimitsConstraintModule_SetTimelockValidationError{
				field:  "PeriodLength",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for AmountAllowed

	if len(errors) > 0 {
		return Transaction_SpendingLimitsConstraintModule_SetTimelockMultiError(errors)
	}

	return nil
}

// Transaction_SpendingLimitsConstraintModule_SetTimelockMultiError is an error
// wrapping multiple validation errors returned by
// Transaction_SpendingLimitsConstraintModule_SetTimelock.ValidateAll() if the
// designated constraints aren't met.
type Transaction_SpendingLimitsConstraintModule_SetTimelockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SpendingLimitsConstraintModule_SetTimelockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SpendingLimitsConstraintModule_SetTimelockMultiError) AllErrors() []error {
	return m
}

// Transaction_SpendingLimitsConstraintModule_SetTimelockValidationError is the
// validation error returned by
// Transaction_SpendingLimitsConstraintModule_SetTimelock.Validate if the
// designated constraints aren't met.
type Transaction_SpendingLimitsConstraintModule_SetTimelockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SpendingLimitsConstraintModule_SetTimelockValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_SpendingLimitsConstraintModule_SetTimelockValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_SpendingLimitsConstraintModule_SetTimelockValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_SpendingLimitsConstraintModule_SetTimelockValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_SpendingLimitsConstraintModule_SetTimelockValidationError) ErrorName() string {
	return "Transaction_SpendingLimitsConstraintModule_SetTimelockValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SpendingLimitsConstraintModule_SetTimelockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SpendingLimitsConstraintModule_SetTimelock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SpendingLimitsConstraintModule_SetTimelockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SpendingLimitsConstraintModule_SetTimelockValidationError{}

// Validate checks the field values on
// Transaction_SpendingLimitsConstraintModule_DeleteTimelock with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_SpendingLimitsConstraintModule_DeleteTimelock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_SpendingLimitsConstraintModule_DeleteTimelock with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_SpendingLimitsConstraintModule_DeleteTimelockMultiError, or nil
// if none found.
func (m *Transaction_SpendingLimitsConstraintModule_DeleteTimelock) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_SpendingLimitsConstraintModule_DeleteTimelock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	if len(errors) > 0 {
		return Transaction_SpendingLimitsConstraintModule_DeleteTimelockMultiError(errors)
	}

	return nil
}

// Transaction_SpendingLimitsConstraintModule_DeleteTimelockMultiError is an
// error wrapping multiple validation errors returned by
// Transaction_SpendingLimitsConstraintModule_DeleteTimelock.ValidateAll() if
// the designated constraints aren't met.
type Transaction_SpendingLimitsConstraintModule_DeleteTimelockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_SpendingLimitsConstraintModule_DeleteTimelockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_SpendingLimitsConstraintModule_DeleteTimelockMultiError) AllErrors() []error {
	return m
}

// Transaction_SpendingLimitsConstraintModule_DeleteTimelockValidationError is
// the validation error returned by
// Transaction_SpendingLimitsConstraintModule_DeleteTimelock.Validate if the
// designated constraints aren't met.
type Transaction_SpendingLimitsConstraintModule_DeleteTimelockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_SpendingLimitsConstraintModule_DeleteTimelockValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_SpendingLimitsConstraintModule_DeleteTimelockValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_SpendingLimitsConstraintModule_DeleteTimelockValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_SpendingLimitsConstraintModule_DeleteTimelockValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_SpendingLimitsConstraintModule_DeleteTimelockValidationError) ErrorName() string {
	return "Transaction_SpendingLimitsConstraintModule_DeleteTimelockValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_SpendingLimitsConstraintModule_DeleteTimelockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_SpendingLimitsConstraintModule_DeleteTimelock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_SpendingLimitsConstraintModule_DeleteTimelockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_SpendingLimitsConstraintModule_DeleteTimelockValidationError{}

// Validate checks the field values on
// Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModule with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModule with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleMultiError,
// or nil if none found.
func (m *Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModule) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TokenAddress

	if len(errors) > 0 {
		return Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleMultiError(errors)
	}

	return nil
}

// Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleMultiError
// is an error wrapping multiple validation errors returned by
// Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModule.ValidateAll()
// if the designated constraints aren't met.
type Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleMultiError) AllErrors() []error {
	return m
}

// Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleValidationError
// is the validation error returned by
// Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModule.Validate
// if the designated constraints aren't met.
type Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleValidationError) ErrorName() string {
	return "Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_TimeLockConstraintModule_DeployTimeLockConstraintModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_TimeLockConstraintModule_DeployTimeLockConstraintModuleValidationError{}

// Validate checks the field values on
// Transaction_TimeLockConstraintModule_EditAmountTimeLock with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_TimeLockConstraintModule_EditAmountTimeLock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_TimeLockConstraintModule_EditAmountTimeLock with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_TimeLockConstraintModule_EditAmountTimeLockMultiError, or nil
// if none found.
func (m *Transaction_TimeLockConstraintModule_EditAmountTimeLock) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_TimeLockConstraintModule_EditAmountTimeLock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Account

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Transaction_TimeLockConstraintModule_EditAmountTimeLockValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Transaction_TimeLockConstraintModule_EditAmountTimeLockValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Transaction_TimeLockConstraintModule_EditAmountTimeLockValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Amount

	if len(errors) > 0 {
		return Transaction_TimeLockConstraintModule_EditAmountTimeLockMultiError(errors)
	}

	return nil
}

// Transaction_TimeLockConstraintModule_EditAmountTimeLockMultiError is an
// error wrapping multiple validation errors returned by
// Transaction_TimeLockConstraintModule_EditAmountTimeLock.ValidateAll() if
// the designated constraints aren't met.
type Transaction_TimeLockConstraintModule_EditAmountTimeLockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_TimeLockConstraintModule_EditAmountTimeLockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_TimeLockConstraintModule_EditAmountTimeLockMultiError) AllErrors() []error {
	return m
}

// Transaction_TimeLockConstraintModule_EditAmountTimeLockValidationError is
// the validation error returned by
// Transaction_TimeLockConstraintModule_EditAmountTimeLock.Validate if the
// designated constraints aren't met.
type Transaction_TimeLockConstraintModule_EditAmountTimeLockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_TimeLockConstraintModule_EditAmountTimeLockValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_TimeLockConstraintModule_EditAmountTimeLockValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_TimeLockConstraintModule_EditAmountTimeLockValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_TimeLockConstraintModule_EditAmountTimeLockValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_TimeLockConstraintModule_EditAmountTimeLockValidationError) ErrorName() string {
	return "Transaction_TimeLockConstraintModule_EditAmountTimeLockValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_TimeLockConstraintModule_EditAmountTimeLockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_TimeLockConstraintModule_EditAmountTimeLock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_TimeLockConstraintModule_EditAmountTimeLockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_TimeLockConstraintModule_EditAmountTimeLockValidationError{}

// Validate checks the field values on
// Transaction_TimeLockConstraintModule_EditAccountTimeLock with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_TimeLockConstraintModule_EditAccountTimeLock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_TimeLockConstraintModule_EditAccountTimeLock with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_TimeLockConstraintModule_EditAccountTimeLockMultiError, or nil
// if none found.
func (m *Transaction_TimeLockConstraintModule_EditAccountTimeLock) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_TimeLockConstraintModule_EditAccountTimeLock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Account

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Transaction_TimeLockConstraintModule_EditAccountTimeLockValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Transaction_TimeLockConstraintModule_EditAccountTimeLockValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Transaction_TimeLockConstraintModule_EditAccountTimeLockValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Transaction_TimeLockConstraintModule_EditAccountTimeLockMultiError(errors)
	}

	return nil
}

// Transaction_TimeLockConstraintModule_EditAccountTimeLockMultiError is an
// error wrapping multiple validation errors returned by
// Transaction_TimeLockConstraintModule_EditAccountTimeLock.ValidateAll() if
// the designated constraints aren't met.
type Transaction_TimeLockConstraintModule_EditAccountTimeLockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_TimeLockConstraintModule_EditAccountTimeLockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_TimeLockConstraintModule_EditAccountTimeLockMultiError) AllErrors() []error {
	return m
}

// Transaction_TimeLockConstraintModule_EditAccountTimeLockValidationError is
// the validation error returned by
// Transaction_TimeLockConstraintModule_EditAccountTimeLock.Validate if the
// designated constraints aren't met.
type Transaction_TimeLockConstraintModule_EditAccountTimeLockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_TimeLockConstraintModule_EditAccountTimeLockValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_TimeLockConstraintModule_EditAccountTimeLockValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_TimeLockConstraintModule_EditAccountTimeLockValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_TimeLockConstraintModule_EditAccountTimeLockValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_TimeLockConstraintModule_EditAccountTimeLockValidationError) ErrorName() string {
	return "Transaction_TimeLockConstraintModule_EditAccountTimeLockValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_TimeLockConstraintModule_EditAccountTimeLockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_TimeLockConstraintModule_EditAccountTimeLock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_TimeLockConstraintModule_EditAccountTimeLockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_TimeLockConstraintModule_EditAccountTimeLockValidationError{}

// Validate checks the field values on
// Transaction_TimeLockConstraintModule_EditTimeLock with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction_TimeLockConstraintModule_EditTimeLock) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_TimeLockConstraintModule_EditTimeLock with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// Transaction_TimeLockConstraintModule_EditTimeLockMultiError, or nil if none found.
func (m *Transaction_TimeLockConstraintModule_EditTimeLock) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_TimeLockConstraintModule_EditTimeLock) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Transaction_TimeLockConstraintModule_EditTimeLockValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Transaction_TimeLockConstraintModule_EditTimeLockValidationError{
					field:  "Time",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Transaction_TimeLockConstraintModule_EditTimeLockValidationError{
				field:  "Time",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Transaction_TimeLockConstraintModule_EditTimeLockMultiError(errors)
	}

	return nil
}

// Transaction_TimeLockConstraintModule_EditTimeLockMultiError is an error
// wrapping multiple validation errors returned by
// Transaction_TimeLockConstraintModule_EditTimeLock.ValidateAll() if the
// designated constraints aren't met.
type Transaction_TimeLockConstraintModule_EditTimeLockMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_TimeLockConstraintModule_EditTimeLockMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_TimeLockConstraintModule_EditTimeLockMultiError) AllErrors() []error { return m }

// Transaction_TimeLockConstraintModule_EditTimeLockValidationError is the
// validation error returned by
// Transaction_TimeLockConstraintModule_EditTimeLock.Validate if the
// designated constraints aren't met.
type Transaction_TimeLockConstraintModule_EditTimeLockValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_TimeLockConstraintModule_EditTimeLockValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_TimeLockConstraintModule_EditTimeLockValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_TimeLockConstraintModule_EditTimeLockValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_TimeLockConstraintModule_EditTimeLockValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_TimeLockConstraintModule_EditTimeLockValidationError) ErrorName() string {
	return "Transaction_TimeLockConstraintModule_EditTimeLockValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_TimeLockConstraintModule_EditTimeLockValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_TimeLockConstraintModule_EditTimeLock.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_TimeLockConstraintModule_EditTimeLockValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_TimeLockConstraintModule_EditTimeLockValidationError{}

// Validate checks the field values on
// Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModule
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModule
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleMultiError,
// or nil if none found.
func (m *Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModule) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TokenAddress

	if len(errors) > 0 {
		return Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleMultiError(errors)
	}

	return nil
}

// Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleMultiError
// is an error wrapping multiple validation errors returned by
// Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModule.ValidateAll()
// if the designated constraints aren't met.
type Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleMultiError) AllErrors() []error {
	return m
}

// Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleValidationError
// is the validation error returned by
// Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModule.Validate
// if the designated constraints aren't met.
type Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleValidationError) ErrorName() string {
	return "Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_VestingPeriodConstraintModule_DeployVestingPeriodConstraintModuleValidationError{}

// Validate checks the field values on
// Transaction_VestingPeriodConstraintModule_SetVestingOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_VestingPeriodConstraintModule_SetVestingOptions) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_VestingPeriodConstraintModule_SetVestingOptions with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_VestingPeriodConstraintModule_SetVestingOptionsMultiError, or
// nil if none found.
func (m *Transaction_VestingPeriodConstraintModule_SetVestingOptions) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_VestingPeriodConstraintModule_SetVestingOptions) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetVestingStart()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Transaction_VestingPeriodConstraintModule_SetVestingOptionsValidationError{
					field:  "VestingStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Transaction_VestingPeriodConstraintModule_SetVestingOptionsValidationError{
					field:  "VestingStart",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetVestingStart()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Transaction_VestingPeriodConstraintModule_SetVestingOptionsValidationError{
				field:  "VestingStart",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for VestedFractionAfterStart

	// no validation rules for VestingRatio

	if len(errors) > 0 {
		return Transaction_VestingPeriodConstraintModule_SetVestingOptionsMultiError(errors)
	}

	return nil
}

// Transaction_VestingPeriodConstraintModule_SetVestingOptionsMultiError is an
// error wrapping multiple validation errors returned by
// Transaction_VestingPeriodConstraintModule_SetVestingOptions.ValidateAll()
// if the designated constraints aren't met.
type Transaction_VestingPeriodConstraintModule_SetVestingOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_VestingPeriodConstraintModule_SetVestingOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_VestingPeriodConstraintModule_SetVestingOptionsMultiError) AllErrors() []error {
	return m
}

// Transaction_VestingPeriodConstraintModule_SetVestingOptionsValidationError
// is the validation error returned by
// Transaction_VestingPeriodConstraintModule_SetVestingOptions.Validate if the
// designated constraints aren't met.
type Transaction_VestingPeriodConstraintModule_SetVestingOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_VestingPeriodConstraintModule_SetVestingOptionsValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_VestingPeriodConstraintModule_SetVestingOptionsValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_VestingPeriodConstraintModule_SetVestingOptionsValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_VestingPeriodConstraintModule_SetVestingOptionsValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_VestingPeriodConstraintModule_SetVestingOptionsValidationError) ErrorName() string {
	return "Transaction_VestingPeriodConstraintModule_SetVestingOptionsValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_VestingPeriodConstraintModule_SetVestingOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_VestingPeriodConstraintModule_SetVestingOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_VestingPeriodConstraintModule_SetVestingOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_VestingPeriodConstraintModule_SetVestingOptionsValidationError{}

// Validate checks the field values on
// Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModule with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModule) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModule with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleMultiError,
// or nil if none found.
func (m *Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModule) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModule) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TokenAddress

	if len(errors) > 0 {
		return Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleMultiError(errors)
	}

	return nil
}

// Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleMultiError
// is an error wrapping multiple validation errors returned by
// Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModule.ValidateAll()
// if the designated constraints aren't met.
type Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleMultiError) AllErrors() []error {
	return m
}

// Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleValidationError
// is the validation error returned by
// Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModule.Validate
// if the designated constraints aren't met.
type Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleValidationError) ErrorName() string {
	return "Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_WhitelistConstraintModule_DeployWhitelistConstraintModule.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_WhitelistConstraintModule_DeployWhitelistConstraintModuleValidationError{}

// Validate checks the field values on
// Transaction_WhitelistConstraintModule_EditWhitelist with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Transaction_WhitelistConstraintModule_EditWhitelist) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_WhitelistConstraintModule_EditWhitelist with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in
// Transaction_WhitelistConstraintModule_EditWhitelistMultiError, or nil if
// none found.
func (m *Transaction_WhitelistConstraintModule_EditWhitelist) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_WhitelistConstraintModule_EditWhitelist) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Account

	// no validation rules for Whitelisted

	if len(errors) > 0 {
		return Transaction_WhitelistConstraintModule_EditWhitelistMultiError(errors)
	}

	return nil
}

// Transaction_WhitelistConstraintModule_EditWhitelistMultiError is an error
// wrapping multiple validation errors returned by
// Transaction_WhitelistConstraintModule_EditWhitelist.ValidateAll() if the
// designated constraints aren't met.
type Transaction_WhitelistConstraintModule_EditWhitelistMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_WhitelistConstraintModule_EditWhitelistMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_WhitelistConstraintModule_EditWhitelistMultiError) AllErrors() []error { return m }

// Transaction_WhitelistConstraintModule_EditWhitelistValidationError is the
// validation error returned by
// Transaction_WhitelistConstraintModule_EditWhitelist.Validate if the
// designated constraints aren't met.
type Transaction_WhitelistConstraintModule_EditWhitelistValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_WhitelistConstraintModule_EditWhitelistValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_WhitelistConstraintModule_EditWhitelistValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_WhitelistConstraintModule_EditWhitelistValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_WhitelistConstraintModule_EditWhitelistValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Transaction_WhitelistConstraintModule_EditWhitelistValidationError) ErrorName() string {
	return "Transaction_WhitelistConstraintModule_EditWhitelistValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_WhitelistConstraintModule_EditWhitelistValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_WhitelistConstraintModule_EditWhitelist.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_WhitelistConstraintModule_EditWhitelistValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_WhitelistConstraintModule_EditWhitelistValidationError{}

// Validate checks the field values on
// Transaction_WhitelistConstraintModule_BulkEditWhitelist with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *Transaction_WhitelistConstraintModule_BulkEditWhitelist) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// Transaction_WhitelistConstraintModule_BulkEditWhitelist with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Transaction_WhitelistConstraintModule_BulkEditWhitelistMultiError, or nil
// if none found.
func (m *Transaction_WhitelistConstraintModule_BulkEditWhitelist) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction_WhitelistConstraintModule_BulkEditWhitelist) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Whitelisted

	if len(errors) > 0 {
		return Transaction_WhitelistConstraintModule_BulkEditWhitelistMultiError(errors)
	}

	return nil
}

// Transaction_WhitelistConstraintModule_BulkEditWhitelistMultiError is an
// error wrapping multiple validation errors returned by
// Transaction_WhitelistConstraintModule_BulkEditWhitelist.ValidateAll() if
// the designated constraints aren't met.
type Transaction_WhitelistConstraintModule_BulkEditWhitelistMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Transaction_WhitelistConstraintModule_BulkEditWhitelistMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Transaction_WhitelistConstraintModule_BulkEditWhitelistMultiError) AllErrors() []error {
	return m
}

// Transaction_WhitelistConstraintModule_BulkEditWhitelistValidationError is
// the validation error returned by
// Transaction_WhitelistConstraintModule_BulkEditWhitelist.Validate if the
// designated constraints aren't met.
type Transaction_WhitelistConstraintModule_BulkEditWhitelistValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Transaction_WhitelistConstraintModule_BulkEditWhitelistValidationError) Field() string {
	return e.field
}

// Reason function returns reason value.
func (e Transaction_WhitelistConstraintModule_BulkEditWhitelistValidationError) Reason() string {
	return e.reason
}

// Cause function returns cause value.
func (e Transaction_WhitelistConstraintModule_BulkEditWhitelistValidationError) Cause() error {
	return e.cause
}

// Key function returns key value.
func (e Transaction_WhitelistConstraintModule_BulkEditWhitelistValidationError) Key() bool {
	return e.key
}

// ErrorName returns error name.
func (e Transaction_WhitelistConstraintModule_BulkEditWhitelistValidationError) ErrorName() string {
	return "Transaction_WhitelistConstraintModule_BulkEditWhitelistValidationError"
}

// Error satisfies the builtin error interface
func (e Transaction_WhitelistConstraintModule_BulkEditWhitelistValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction_WhitelistConstraintModule_BulkEditWhitelist.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Transaction_WhitelistConstraintModule_BulkEditWhitelistValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Transaction_WhitelistConstraintModule_BulkEditWhitelistValidationError{}
